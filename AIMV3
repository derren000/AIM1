--// Cache

local select = select
local pcall, getgenv, next, Vector2, mathclamp, type, mousemoverel = select(1, pcall, getgenv, next, Vector2.new, math.clamp, type, mousemoverel or (Input and Input.MouseMove))

--// Preventing Multiple Processes

pcall(function()
	getgenv().Aimbot.Functions:Exit()
end)

--// Environment

getgenv().Aimbot = {}
local Environment = getgenv().Aimbot

--// Services

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local CoreGui = game:GetService("CoreGui")

--// Variables

local RequiredDistance, Typing, Running, Animation, ServiceConnections = 2000, false, false, nil, {}

--// Script Settings

Environment.Settings = {
	Enabled = true,
	TeamCheck = false,
	AliveCheck = true,
	WallCheck = false,
	Sensitivity = 0,
	ThirdPerson = false,
	ThirdPersonSensitivity = 3,
	TriggerKey = "LeftControl",
	 Toggle = false,
	LockPart = "Head"
}

Environment.FOVSettings = {
	Enabled = true,
	Visible = true,
	Amount = 90,
	Color = Color3.fromRGB(255, 255, 255),
	LockedColor = Color3.fromRGB(255, 70, 70),
	Transparency = 0.5,
	Sides = 60,
	Thickness = 1,
	Filled = false
}

Environment.FOVCircle = Drawing.new("Circle")

--// =================================================================
--//                        MOVABLE UI WINDOW
--// =================================================================

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "AimbotUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.DisplayOrder = 999999
ScreenGui.Enabled = false  -- toggled with P
ScreenGui.Parent = CoreGui

local Frame = Instance.new("Frame")
Frame.Size = UDim2.new(0, 220, 0, 120)
Frame.Position = UDim2.new(0.5, -110, 0.4, 0)
Frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
Frame.BackgroundTransparency = 0.15
Frame.BorderSizePixel = 0
Frame.Active = true
Frame.Draggable = true
Frame.Parent = ScreenGui

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, 0, 0, 24)
Title.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
Title.BorderSizePixel = 0
Title.Text = "Aimbot Settings"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 16
Title.Parent = Frame

-- KEYBIND BUTTON
local KeybindBtn = Instance.new("TextButton")
KeybindBtn.Size = UDim2.new(1, -20, 0, 32)
KeybindBtn.Position = UDim2.new(0, 10, 0, 35)
KeybindBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
KeybindBtn.BorderSizePixel = 0
KeybindBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
KeybindBtn.TextSize = 16
KeybindBtn.Text = "Set Keybind: " .. Environment.Settings.TriggerKey
KeybindBtn.Parent = Frame

-- TOGGLE MODE BUTTON
local ToggleBtn = Instance.new("TextButton")
ToggleBtn.Size = UDim2.new(1, -20, 0, 32)
ToggleBtn.Position = UDim2.new(0, 10, 0, 75)
ToggleBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
ToggleBtn.BorderSizePixel = 0
ToggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleBtn.TextSize = 16
ToggleBtn.Text = "Mode: HOLD"
ToggleBtn.Parent = Frame

local listeningForKey = false

-- SET KEYBIND
KeybindBtn.MouseButton1Click:Connect(function()
	if listeningForKey then return end

	listeningForKey = true
	KeybindBtn.Text = "Press a key..."

	local conn
	conn = UserInputService.InputBegan:Connect(function(Input)
		if Input.KeyCode ~= Enum.KeyCode.Unknown then
			Environment.Settings.TriggerKey = tostring(Input.KeyCode.Name)
			KeybindBtn.Text = "Set Keybind: " .. Environment.Settings.TriggerKey
			listeningForKey = false
			conn:Disconnect()
		end
	end)
end)

-- CHANGE HOLD / TOGGLE MODE
ToggleBtn.MouseButton1Click:Connect(function()
	Environment.Settings.Toggle = not Environment.Settings.Toggle
	ToggleBtn.Text = Environment.Settings.Toggle and "Mode: TOGGLE" or "Mode: HOLD"
end)

-- OPEN/CLOSE UI WITH P
UserInputService.InputBegan:Connect(function(Input, GPE)
	if GPE then return end
	if Input.KeyCode == Enum.KeyCode.P then
		ScreenGui.Enabled = not ScreenGui.Enabled
	end
end)

--// =================================================================
--//                            AIMBOT LOGIC
--// =================================================================

local function CancelLock()
	Environment.Locked = nil
	if Animation then
		Animation:Cancel()
		Animation = nil
	end
	Environment.FOVCircle.Color = Environment.FOVSettings.Color
end

local function GetClosestPlayer()
	-- cache mouse position once per call (faster)
	local mousePos = Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)

	if not Environment.Locked then
		RequiredDistance = (Environment.FOVSettings.Enabled and Environment.FOVSettings.Amount or 2000)

		-- =====================================================
		-- 1. CHECK PLAYERS FIRST (fast path)
		-- =====================================================
		for _, v in next, Players:GetPlayers() do
			if v ~= LocalPlayer then
				local char = v.Character
				if char and char:FindFirstChild(Environment.Settings.LockPart) and char:FindFirstChildOfClass("Humanoid") then
					if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
					if Environment.Settings.AliveCheck and char:FindFirstChildOfClass("Humanoid").Health <= 0 then continue end
					if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({char[Environment.Settings.LockPart].Position}, char:GetDescendants())) > 0 then continue end

					local ok, vec = pcall(function()
						return Camera:WorldToViewportPoint(char[Environment.Settings.LockPart].Position)
					end)
					if not ok then continue end
					local OnScreen = vec.Z > 0
					local Distance = (mousePos - Vector2(vec.X, vec.Y)).Magnitude

					if Distance < RequiredDistance and OnScreen then
						RequiredDistance = Distance
						Environment.Locked = v
					end
				end
			end
		end

		-- =====================================================
		-- 2. CHECK NPCs ONLY IF NO PLAYER FOUND OR closer possible
		--    (iterate workspace descendants once)
		-- =====================================================
		-- Only proceed if there's still room to find something closer than current RequiredDistance
		if RequiredDistance > 0 then
			local desc = workspace:GetDescendants()
			for i = 1, #desc do
				local obj = desc[i]
				if obj and obj:IsA("Humanoid") then
					local model = obj.Parent
					-- Skip player's own character or players' characters (we already checked players)
					if model ~= LocalPlayer.Character and not Players:GetPlayerFromCharacter(model) then
						local part = model:FindFirstChild(Environment.Settings.LockPart)
						if part then
							if Environment.Settings.AliveCheck and obj.Health <= 0 then continue end
							if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({part.Position}, model:GetDescendants())) > 0 then continue end

							local ok, vec = pcall(function()
								return Camera:WorldToViewportPoint(part.Position)
							end)
							if not ok then continue end
							local OnScreen = vec.Z > 0
							local Distance = (mousePos - Vector2(vec.X, vec.Y)).Magnitude

							if Distance < RequiredDistance and OnScreen then
								RequiredDistance = Distance
								-- create a light wrapper so rest of code can treat it similar to player
								Environment.Locked = { Character = model, _isNPC = true }
							end
						end
					end
				end
			end
		end

	else
		-- When already locked:
		-- If we are in toggle mode and Running -> keep lock regardless of mouse movement (user requested)
		-- If we are NOT in toggle mode -> keep previous behavior: unlock when target leaves FOV radius
		local lockChar = Environment.Locked and Environment.Locked.Character
		if lockChar and lockChar:FindFirstChild(Environment.Settings.LockPart) then
			-- compute current distance from mouse to target
			local ok, vec = pcall(function()
				return Camera:WorldToViewportPoint(lockChar[Environment.Settings.LockPart].Position)
			end)
			if not ok then
				CancelLock()
				return
			end
			local OnScreen = vec.Z > 0
			local Distance = (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(vec.X, vec.Y)).Magnitude

			-- only cancel when: not toggle mode AND Distance > RequiredDistance OR the target is offscreen
			if (not Environment.Settings.Toggle and Distance > RequiredDistance) or (not OnScreen) then
				CancelLock()
			else
				-- keep lock (important: don't recalc RequiredDistance here; keep it as previous value so we don't flip)
			end
		else
			CancelLock()
		end
	end
end

-- TYPING DISABLES AIMBIND
ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
	Typing = true
end)

ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
	Typing = false
end)

-- MAIN LOOP
local function Load()
	ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
		if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
			Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
			Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
			Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
			Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
			Environment.FOVCircle.Color = Environment.FOVSettings.Color
			Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
			Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
			Environment.FOVCircle.Position = Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
		else
			Environment.FOVCircle.Visible = false
		end

		if Running and Environment.Settings.Enabled then
			GetClosestPlayer()

			if Environment.Locked then
				-- ensure the locked Character still exists and has lock part before attempting to aim
				local ok, targetPos = pcall(function()
					return Environment.Locked.Character[Environment.Settings.LockPart].Position
				end)
				if not ok then
					CancelLock()
					return
				end

				if Environment.Settings.ThirdPerson then
					Environment.Settings.ThirdPersonSensitivity = mathclamp(Environment.Settings.ThirdPersonSensitivity, 0.1, 5)

					local Vector = Camera:WorldToViewportPoint(targetPos)
					mousemoverel(
						(Vector.X - UserInputService:GetMouseLocation().X) * Environment.Settings.ThirdPersonSensitivity,
						(Vector.Y - UserInputService:GetMouseLocation().Y) * Environment.Settings.ThirdPersonSensitivity
					)
				else
					if Environment.Settings.Sensitivity > 0 then
						Animation = TweenService:Create(Camera, TweenInfo.new(
							Environment.Settings.Sensitivity,
							Enum.EasingStyle.Sine,
							Enum.EasingDirection.Out
						), {
							CFrame = CFrame.new(Camera.CFrame.Position,
								targetPos)
						})
						Animation:Play()
					else
						Camera.CFrame = CFrame.new(Camera.CFrame.Position,
							targetPos)
					end
				end

				Environment.FOVCircle.Color = Environment.FOVSettings.LockedColor
			end
		end
	end)

	ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
		if not Typing then
			pcall(function()
				-- Input.KeyCode might be Enum.KeyCode.Unknown if using gamepad/mouse; this is fine
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running
						-- in toggle mode, if we switched off, cancel lock; if turned on, keep searching/locking and do not unlock when moving mouse
						if not Running then CancelLock() end
					else
						Running = true
					end
				end
			end)
		end
	end)

	ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
		if not Typing then
			-- Only do release logic for HOLD mode (toggle mode should persist until toggled off)
			if not Environment.Settings.Toggle then
				pcall(function()
					if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
						Running = false
						CancelLock()
					end
				end)
			end
		end
	end)
end

-- FUNCTIONS
Environment.Functions = {}

function Environment.Functions:Exit()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	if Environment.FOVCircle.Remove then
		Environment.FOVCircle:Remove()
	end

	getgenv().Aimbot.Functions = nil
	getgenv().Aimbot = nil

	Load = nil
	GetClosestPlayer = nil
	CancelLock = nil
end

function Environment.Functions:Restart()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	Load()
end

function Environment.Functions:ResetSettings()
	Environment.Settings.TriggerKey = "LeftControl"
	Environment.Settings.Toggle = false
end

-- LOAD AIMBOT
Load()
